/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module motherboard (
        input wire clk,
        input wire rst,
        input wire [2:0] irq,
        input wire slowclk,
        input wire acc_miso,
        input wire [7:0] buttons,
        output reg [31:0] id,
        output reg [31:0] ia,
        output reg [31:0] ma,
        output reg [31:0] mrd,
        output reg [31:0] mwd,
        output reg [31:0] output_buffer,
        output reg [31:0] input_buffer,
        output reg [3:0] lcd_spi_out,
        output reg [3:0][15:0] debug
    );
    logic M_beta_slowclk;
    logic M_beta_rst;
    logic M_beta_irq;
    logic M_beta_lcd_spi_busy;
    logic M_beta_acc_spi_busy;
    logic [31:0] M_beta_spi_in_data;
    logic [31:0] M_beta_instruction;
    logic [31:0] M_beta_mem_data_input;
    logic [31:0] M_beta_ia;
    logic [31:0] M_beta_mem_data_address;
    logic [31:0] M_beta_mem_data_output;
    logic M_beta_wr;
    logic M_beta_lcd_enable;
    logic M_beta_acc_enable;
    logic [3:0][15:0] M_beta_debug;
    
    beta_cpu beta (
        .clk(clk),
        .slowclk(M_beta_slowclk),
        .rst(M_beta_rst),
        .irq(M_beta_irq),
        .lcd_spi_busy(M_beta_lcd_spi_busy),
        .acc_spi_busy(M_beta_acc_spi_busy),
        .spi_in_data(M_beta_spi_in_data),
        .instruction(M_beta_instruction),
        .mem_data_input(M_beta_mem_data_input),
        .ia(M_beta_ia),
        .mem_data_address(M_beta_mem_data_address),
        .mem_data_output(M_beta_mem_data_output),
        .wr(M_beta_wr),
        .lcd_enable(M_beta_lcd_enable),
        .acc_enable(M_beta_acc_enable),
        .debug(M_beta_debug)
    );
    
    
    logic [7:0] M_lcd_out_byte;
    logic M_lcd_dcx_in;
    logic M_lcd_enable;
    logic M_lcd_mosi;
    logic M_lcd_scl;
    logic M_lcd_dcx_out;
    logic M_lcd_csx;
    logic M_lcd_next_byte;
    
    lcd_spi_driver lcd (
        .clk(clk),
        .rst(rst),
        .out_byte(M_lcd_out_byte),
        .dcx_in(M_lcd_dcx_in),
        .enable(M_lcd_enable),
        .mosi(M_lcd_mosi),
        .scl(M_lcd_scl),
        .dcx_out(M_lcd_dcx_out),
        .csx(M_lcd_csx),
        .next_byte(M_lcd_next_byte)
    );
    
    
    localparam _MP_SIZE_1909626421 = 3'h5;
    localparam _MP_DIV_1909626421 = 1'h0;
    localparam _MP_TOP_1909626421 = 1'h0;
    localparam _MP_UP_1909626421 = 1'h1;
    logic [4:0] M_frequency_divider_value;
    
    counter #(
        .SIZE(_MP_SIZE_1909626421),
        .DIV(_MP_DIV_1909626421),
        .TOP(_MP_TOP_1909626421),
        .UP(_MP_UP_1909626421)
    ) frequency_divider (
        .clk(clk),
        .rst(rst),
        .value(M_frequency_divider_value)
    );
    
    
    localparam _MP_SEED_620898034 = 33'h19430f418;
    logic M_pn_next;
    logic [31:0] M_pn_num;
    
    pn_gen #(
        .SEED(_MP_SEED_620898034)
    ) pn (
        .clk(clk),
        .rst(rst),
        .seed(33'h19430f418),
        .next(M_pn_next),
        .num(M_pn_num)
    );
    
    
    localparam MEMORY_SIZE = 10'h200;
    localparam _MP_WORDS_1498490836 = 10'h200;
    logic [8:0] M_instruction_unit_addr;
    logic [31:0] M_instruction_unit_out;
    logic [9:0] M_instruction_unit_numinstr;
    
    instruction_rom #(
        .WORDS(_MP_WORDS_1498490836)
    ) instruction_unit (
        .addr(M_instruction_unit_addr),
        .out(M_instruction_unit_out),
        .numinstr(M_instruction_unit_numinstr)
    );
    
    
    localparam _MP_WORDS_221975715 = 10'h200;
    logic [10:0] M_memory_unit_raddr;
    logic [10:0] M_memory_unit_waddr;
    logic [31:0] M_memory_unit_wd;
    logic M_memory_unit_we;
    logic [31:0] M_memory_unit_mrd;
    logic [10:0] M_memory_unit_ia;
    logic M_memory_unit_instruction_we;
    logic [31:0] M_memory_unit_instruction_wd;
    logic [31:0] M_memory_unit_id;
    
    memory_unit #(
        .WORDS(_MP_WORDS_221975715)
    ) memory_unit (
        .clk(clk),
        .raddr(M_memory_unit_raddr),
        .waddr(M_memory_unit_waddr),
        .wd(M_memory_unit_wd),
        .we(M_memory_unit_we),
        .mrd(M_memory_unit_mrd),
        .ia(M_memory_unit_ia),
        .instruction_we(M_memory_unit_instruction_we),
        .instruction_wd(M_memory_unit_instruction_wd),
        .id(M_memory_unit_id)
    );
    
    
    logic [31:0] D_system_output_buffer_d, D_system_output_buffer_q = 0;
    logic [31:0] D_system_input_buffer_d, D_system_input_buffer_q = 0;
    logic [8:0] D_writer_counter_d, D_writer_counter_q = 0;
    localparam E_MotherboardStates_INSTRUCTIONLOAD = 3'h0;
    localparam E_MotherboardStates_RUN = 3'h1;
    localparam E_MotherboardStates_LOAD_OUTPUT = 3'h2;
    localparam E_MotherboardStates_DISPLAY_OUTPUT = 3'h3;
    localparam E_MotherboardStates_UPDATE_INPUT = 3'h4;
    logic [2:0] D_motherboard_d, D_motherboard_q = 3'h0;
    always @* begin
        D_system_input_buffer_d = D_system_input_buffer_q;
        D_writer_counter_d = D_writer_counter_q;
        D_motherboard_d = D_motherboard_q;
        D_system_output_buffer_d = D_system_output_buffer_q;
        
        M_instruction_unit_addr = 1'h0;
        M_beta_irq = (|irq);
        M_beta_lcd_spi_busy = ~M_lcd_next_byte;
        lcd_spi_out = {M_lcd_csx, M_lcd_dcx_out, M_lcd_mosi, M_lcd_scl};
        M_lcd_out_byte = M_beta_mem_data_output[3'h7:1'h0];
        M_lcd_dcx_in = M_beta_mem_data_output[4'h8];
        M_lcd_enable = M_beta_lcd_enable;
        M_beta_acc_spi_busy = 1'h0;
        M_pn_next = ((&M_frequency_divider_value));
        M_beta_spi_in_data = {M_pn_num[5'h1f:4'h8], buttons};
        if ((|irq)) begin
            if (irq[1'h0]) begin
                D_system_input_buffer_d = 32'hb0;
            end else begin
                if (irq[1'h1]) begin
                    D_system_input_buffer_d = 32'hb1;
                end else begin
                    if (irq[2'h2]) begin
                        D_system_input_buffer_d = 32'hb2;
                    end
                end
            end
        end
        M_beta_slowclk = slowclk;
        M_beta_rst = rst;
        M_beta_instruction = M_memory_unit_id;
        M_beta_mem_data_input = M_memory_unit_mrd;
        M_memory_unit_ia = M_beta_ia[5'h1f:1'h0];
        M_memory_unit_wd = M_beta_mem_data_output;
        M_memory_unit_we = M_beta_wr;
        M_memory_unit_waddr = M_beta_mem_data_address[5'h1f:1'h0];
        M_memory_unit_raddr = M_beta_mem_data_address[5'h1f:1'h0];
        M_memory_unit_instruction_we = 1'h0;
        M_memory_unit_instruction_wd = 32'h0;
        
        case (D_motherboard_q)
            3'h0: begin
                M_beta_rst = 1'h1;
                D_writer_counter_d = D_writer_counter_q + 1'h1;
                M_instruction_unit_addr = D_writer_counter_q;
                M_memory_unit_instruction_wd = M_instruction_unit_out;
                M_memory_unit_instruction_we = 1'h1;
                M_memory_unit_ia = D_writer_counter_q << 2'h2;
                if ((D_writer_counter_q + 1'h1) == 10'h200) begin
                    D_motherboard_d = 3'h1;
                end
            end
            3'h1: begin
                if (slowclk) begin
                    D_motherboard_d = 3'h2;
                end else begin
                    D_motherboard_d = 3'h1;
                end
            end
            3'h2: begin
                M_memory_unit_raddr = 32'hc;
                D_motherboard_d = 3'h3;
            end
            3'h3: begin
                D_system_output_buffer_d = M_memory_unit_mrd;
                D_motherboard_d = 3'h4;
            end
            3'h4: begin
                M_memory_unit_waddr = 32'h10;
                M_memory_unit_wd = D_system_input_buffer_q;
                M_memory_unit_we = 1'h1;
                D_motherboard_d = 3'h1;
            end
        endcase
        output_buffer = D_system_output_buffer_q;
        input_buffer = D_system_input_buffer_q;
        ia = M_beta_ia;
        id = M_memory_unit_id;
        ma = M_beta_mem_data_address;
        mrd = M_memory_unit_mrd;
        mwd = M_beta_mem_data_output;
        debug = M_beta_debug;
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_system_output_buffer_q <= 0;
            D_system_input_buffer_q <= 0;
            D_motherboard_q <= 3'h0;
        end else begin
            D_system_output_buffer_q <= D_system_output_buffer_d;
            D_system_input_buffer_q <= D_system_input_buffer_d;
            D_motherboard_q <= D_motherboard_d;
        end
    end
    always @(posedge (clk)) begin
        D_writer_counter_q <= D_writer_counter_d;
        
    end
endmodule