/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module ws2812b_driver #(
        parameter PIXEL_COUNT = 9'h100
    ) (
        input wire clk,
        input wire rst,
        input wire update,
        input wire [23:0] color,
        input wire clear,
        output reg [($clog2(PIXEL_COUNT))-1:0] pixel_address,
        output reg data,
        output reg next_pixel,
        output reg reset,
        output reg done
    );
    localparam E_States_SEND_PIXEL = 2'h0;
    localparam E_States_RESET = 2'h1;
    localparam E_States_CLEAR = 2'h2;
    logic [1:0] D_state_d, D_state_q = 2'h1;
    logic [($clog2(PIXEL_COUNT))-1:0] D_pixel_address_ctr_d, D_pixel_address_ctr_q = 1'h0;
    logic [4:0] D_bit_ctr_d, D_bit_ctr_q = 0;
    logic [6:0] D_ctr_d, D_ctr_q = 0;
    logic [12:0] D_rst_ctr_d, D_rst_ctr_q = 0;
    logic D_update_request_d, D_update_request_q = 1'h0;
    logic D_clear_request_d, D_clear_request_q = 1'h1;
    always @* begin
        D_rst_ctr_d = D_rst_ctr_q;
        D_pixel_address_ctr_d = D_pixel_address_ctr_q;
        D_state_d = D_state_q;
        D_bit_ctr_d = D_bit_ctr_q;
        D_ctr_d = D_ctr_q;
        D_update_request_d = D_update_request_q;
        D_clear_request_d = D_clear_request_q;
        
        data = 1'h0;
        reset = 1'h0;
        next_pixel = 1'h0;
        D_rst_ctr_d = D_rst_ctr_q;
        D_pixel_address_ctr_d = D_pixel_address_ctr_q;
        D_state_d = D_state_q;
        D_bit_ctr_d = D_bit_ctr_q;
        D_ctr_d = D_ctr_q;
        D_update_request_d = D_update_request_q;
        D_clear_request_d = D_clear_request_q;
        pixel_address = D_pixel_address_ctr_q;
        if (~D_update_request_q) begin
            D_update_request_d = update;
        end
        if (~D_clear_request_q) begin
            D_clear_request_d = clear;
        end
        done = 1'h0;
        
        case (D_state_q)
            2'h0: begin
                if (color[D_bit_ctr_q]) begin
                    data = D_ctr_q < 7'h50;
                end else begin
                    data = D_ctr_q < 6'h28;
                end
                D_ctr_d = D_ctr_q + 1'h1;
                if (D_ctr_q == 7'h7d) begin
                    D_ctr_d = 1'h0;
                    D_bit_ctr_d = D_bit_ctr_q + 1'h1;
                    if (D_bit_ctr_q == 5'h17) begin
                        D_bit_ctr_d = 1'h0;
                        next_pixel = 1'h1;
                        D_pixel_address_ctr_d = D_pixel_address_ctr_q + 1'h1;
                        if (D_pixel_address_ctr_q == PIXEL_COUNT - 1'h1) begin
                            done = 1'h1;
                            D_state_d = 2'h1;
                        end
                    end
                end
            end
            2'h1: begin
                reset = 1'h1;
                D_pixel_address_ctr_d = 1'h0;
                if ((&D_rst_ctr_q)) begin
                    D_rst_ctr_d = 1'h0;
                    if (D_update_request_q) begin
                        D_update_request_d = 1'h0;
                        D_state_d = 2'h0;
                    end
                    if (D_clear_request_q) begin
                        D_clear_request_d = 1'h0;
                        D_state_d = 2'h2;
                    end
                end else begin
                    D_rst_ctr_d = D_rst_ctr_q + 1'h1;
                end
            end
            2'h2: begin
                data = D_ctr_q < 6'h28;
                D_ctr_d = D_ctr_q + 1'h1;
                if (D_ctr_q == 7'h7d) begin
                    D_ctr_d = 1'h0;
                    D_bit_ctr_d = D_bit_ctr_q + 1'h1;
                    if (D_bit_ctr_q == 5'h17) begin
                        D_bit_ctr_d = 1'h0;
                        D_pixel_address_ctr_d = D_pixel_address_ctr_q + 1'h1;
                        if (D_pixel_address_ctr_q == PIXEL_COUNT - 1'h1) begin
                            D_state_d = 2'h1;
                        end
                    end
                end
            end
        endcase
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_state_q <= 2'h1;
            D_pixel_address_ctr_q <= 1'h0;
            D_bit_ctr_q <= 0;
            D_ctr_q <= 0;
            D_rst_ctr_q <= 0;
            D_update_request_q <= 1'h0;
            D_clear_request_q <= 1'h1;
        end else begin
            D_state_q <= D_state_d;
            D_pixel_address_ctr_q <= D_pixel_address_ctr_d;
            D_bit_ctr_q <= D_bit_ctr_d;
            D_ctr_q <= D_ctr_d;
            D_rst_ctr_q <= D_rst_ctr_d;
            D_update_request_q <= D_update_request_d;
            D_clear_request_q <= D_clear_request_d;
        end
    end
endmodule